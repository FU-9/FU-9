#### 互斥锁
进城之间数据不共享，但是共享同一套文件系统，所以访问同一个文件，或同一个打印终端，是没有问题的，而共享带来的是竞争，竞争带来的结果就是错乱，如下
```
#并发运行，效率高，但竞争同一打印终端，带来了打印错乱
from multiprocessing import Process
import os,time

def word():
  print('%s is runing' %os.getpid())
  time.sleep(2)
  print('%s is done' %os.getpid())

if __name__ == '__main__':
  for i in range(3):
    p = Process(target=word)
    p.start()
```
如何控制，就是加锁处理。而互斥锁的意思就是互相排斥，如果把多个进程比喻为多个人，互斥锁的工作原理就是多个人都要去争抢同一个资源：卫生间，一个人抢到卫生间后上一把锁，其他人都要等着，等到这个任务完成后释放锁，其他人才有可能有一个抢到。。。所以互斥锁的原理，就是把并发改成串行，降低了小路，但保证了数据的安全
```
#由并发变成了串行，牺牲了运行效率，但避免了竞争
from multiprocessing import Process,Lock
import os,time

def work(lock):
  lock.acquire()#加锁
  print('%s is runing' %os.getpid())
  time.sleep(2)
  print('%s is done' %os.getpid())
  lock.release()#释放锁

if __name__ == '__main__':
  lock = Lock()
  for i in range(3):
    p = Process(target=work,args=(lock,))
    p.start()
```
##### 互斥锁与join
使用join可以将并发编程串行，互斥锁的原理也是将并发变成串行，那我们直接使用join就可以了啊，为何还要互斥锁，join是将一个任务整体串行，而互斥锁的好处则是可以将一个任务中的某一段代码串行
