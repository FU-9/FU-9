#### multiprocessing模块介绍
python中的多线程无法利用多核优势，如果想充分的使用多核cpu的资源（os.cpu_count()查看），在Python中大部分情况需要使用多进程。
Python提供了multiprocessing.multiprocessing模块用来开启子进程，并在子进程中定制的任务（比如函数），该模块与多线程模块threading的编程接口类似。multiprocessing模块的功能众多：支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。
需要注意的一点是：与线程不同，进程没有任何共享状态，进程需改 的数据，改动仅限于该进程内

#### Process类介绍
+ 创建进程的类
```
Process([group[,target[,name[,args[,kwargs]]]]])
由该类实例化得到的对象，可用来开启一个子进程
注：
 1、需要使用关键字的方式来制定参数
 2、args制定的为传给target函数的位置参数，是一个元祖形式，必须有逗号。
```
+ 参数介绍
```
group参数未使用，值始终为None
target标示调用对象，即子进程要执行的任务
args标示调用对象的位置参数元组args=(1,2,3)
kwargs标示调用对象的字典，kwargs={"name":"race","age",23}
name为子进程的名称
```
+ 方法介绍
```
p.start():启动进程，并调用该子进程中的p.run()
p.run():进程启动是运行的方法，正式它去调用target指定的函数，我们自定义类中一定要实现该方法

p.terminate():强制终止进程p，不会进程任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也不会被释放，进而导致死锁
p.is_alive():如果p仍然运行，返回True

p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态）。timeout是可选的超时时间。
```
+ 属性介绍
```
p.daemon:默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置
p.name:进程的名称
p.pid:进程的pid
```
#### Process类的使用
注意：在windows中process()必须放到#if __name__ == '__main__':下
创建并开启子进程的方式一
```
import time
import random
from multiprocessing import Process
def task(name):
  print('%s runing' %name)
  time.sleep(random.randint(1,5))
  print('%s run end' %name)

if __name__ == '__main__':
  #实例化得到四个对象
  p1 = Process(target=task,args=('p1',))#必须加','号
  p2 = Process(target=task,args=('p2',))
  p3 = Process(target=task,args=('p3',))
  p4 = Process(target=task,args=('p4',))

  #调用对象下的方法，开启四个进程
  p1.start()
  p2.start()
  p3.start()
  p4.start()

  print("主")
```
创建并开启子进程的方式二
```
import time
import random
from multiprocessing import Process
class Pro(Process):
  def __init__(self,name):
    super().__init__()
    self.name = name;

  def run(self):
    print('%s runing'%self.name)
    time.sleep(random.randint(1,5))
    print('%s end'%self.name)

  if __name__ == '__main__':
    #实例化得到四个对象
    p1 = Pro('p1')
    p2 = Pro('p2')
    p3 = Pro('p3')
    p4 = Pro('p4')

    #调用对象下的方法，开启四个进程
    p1.start() #start会自动调用run
    p2.start()
    p3.start()
    p4.start()

    print(主)
```
